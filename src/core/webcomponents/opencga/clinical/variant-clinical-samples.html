<!--
  ~ Copyright 2015-2016 OpenCB
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~     http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<link rel="import" href="../variant/variant-sample-grid.html">
<link rel="import" href="../catalog/samples/opencga-sample-filter.html">
<link rel="import" href="../catalog/samples/opencga-family-editor-new.html">
<link rel="import" href="../opencga-active-filters.html">
<link rel="import" href="../opencga-message-dialog.html">

<dom-module id="variant-clinical-samples">
    <template>
        <style include="jso-styles"></style>

        <div class="row">
            <div class="col-md-2">
                <opencga-sample-filter study="{{study}}" config="{{config}}" samples="{{samples}}"
                                       opencga-client="{{opencgaClient}}" query="{{query}}" search="{{search}}">
                </opencga-sample-filter>
            </div>

            <div class="col-md-10">
                <br>
                <opencga-active-filters opencga-client="{{opencgaClient}}" query="{{query}}" filters="{{config.filters}}" default-study="{{study.alias}}"
                                        alias="{{activeFilterAlias}}" refresh="{{search}}" on-clear="onClear" on-filterchange="onFilterChange">
                </opencga-active-filters>

                <h3>Sample Results</h3>
                <variant-sample-grid opencga-client="{{opencgaClient}}" study="{{study}}" samples="{{samples}}" search="{{search}}"></variant-sample-grid>

                <br>
                <h3>Analysis Type</h3>
                <div id="{{prefix}}toolbar">
                    <div class="btn-group btn-group-sm">
                        <button id="singleButton" class="button" on-click="addAnalysis">
                            <img src="[[importPath]]images/analysis_single_button.png" height="60">
                        </button>
                        <button id="duoButton" class="button" on-click="addAnalysis">
                            <img src="[[importPath]]images/analysis_duo_button.png" height="60">
                        </button>
                        <button id="trioButton" class="button" on-click="addAnalysis">
                            <img src="[[importPath]]images/analysis_trio_button.png" height="60">
                        </button>
                        <button id="familyButton" class="button" on-click="addAnalysis">
                            <img src="[[importPath]]images/analysis_family_button.png" height="60">
                        </button>
                        <button id="autoButton" class="button" on-click="addAnalysis">
                            <img src="[[importPath]]images/analysis_auto_button.png" height="60">
                        </button>
                    </div>
                </div>
                <br>


                <div style="padding: 10px 0px">
                    <h3>Clinical Analysis</h3>
                    <template is="dom-if" if="{{messageSuccess}}">
                        <div class="alert alert-success" role="alert" id="{{prefix}}messageSuccess" style="margin:0 auto;">{{messageSuccessText}}</div>
                    </template>
                    <template is="dom-if" if="{{messageError}}">
                        <div class="alert alert-danger" role="alert" id="{{prefix}}messageError" style="margin:0 auto;">{{messageErrorText}}</div>
                    </template>
                    <template is="dom-if" if="{{unsavedAnalysis}}">
                        <div class="alert alert-warning" role="alert" style="margin:0 auto;">There are unsaved analyses!</div>
                    </template>

                    <div id="toolbar">
                        <button id="{{prefix}}DeleteAnalysisButton" class="btn btn-danger disabled" on-click="deleteAnalysis">
                            <i class="fa fa-times"></i>&nbsp;Delete
                        </button>
                    </div>

                    <table id="{{prefix}}tableAnalysis" data-toolbar="#toolbar" data-show-columns="true" data-show-export="true"
                           data-show-pagination-switch="true" data-pagination="true" data-page-size="5" data-page-list="[5, 10, 25]"
                           data-checkbox-header="false" data-maintain-selected="true" style="cursor: pointer;">
                        <thead style="background-color: #eee"></thead>
                    </table>
                </div>
            </div>
        </div>

        <!-- Modal dialog for Family Editor-->
        <div class="modal fade" id="{{prefix}}FamilyEditor" tabindex="-1" role="dialog"
             aria-labelledby="familyEditorLabel">
            <div class="modal-dialog modal-sm" role="document" style="width: 1300px;">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span
                                aria-hidden="true">&times;</span></button>
                        <h4 class="modal-title" id="{{prefix}}FamilyEditorLabel">Family Editor</h4>
                    </div>
                    <div class="modal-body" style="height: 500px">
                        <template is="dom-if" if="{{showModalFamilyEditor}}" restamp="true">

                            <opencga-family-editor-new study="{{study}}" samples="{{_samplesAnalysis}}"
                                                       opencga-client="{{opencgaClient}}" family="{{family}}"
                                                       on-familychange="familyChange">
                            </opencga-family-editor-new>
                        </template>
                    </div>

                    <div class="modal-footer">
                        <button type="button" class="btn btn-primary" data-dismiss="modal" on-click="checkFamily">OK
                        </button>
                    </div>
                </div>
            </div>
        </div>


        <!-- Modal dialog for warnings -->
        <div class="modal fade" id="{{prefix}}warningModal" tabindex="-1" role="dialog"
             aria-labelledby="warningLabel" data-backdrop="static" data-keyboard="false">
            <div class="modal-dialog modal-sm" role="document" style="width: 500px;">
                <div class="modal-content">
                    <div class="modal-header alert alert-danger">
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span
                                aria-hidden="true">&times;</span></button>
                        <h4 class="modal-title">Warning!</h4>
                    </div>
                    <div id="{{prefix}}warningMsgDiv" class="modal-body" style="height: 100px"></div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-primary" data-dismiss="modal">OK</button>
                    </div>
                </div>
            </div>
        </div>

        <opencga-message-dialog opencga-client="{{opencgaClient}}" show-message-modal="{{showMessageModal}}"
                                settings-message-modal="{{settingsMessageModal}}">
        </opencga-message-dialog>
    </template>

    <script>
        class VariantClinicalSamples extends Polymer.Element {

            constructor() {
                super();

                this.prefix = "sample" + Utils.randomString(6);
            }

            static get is() {
                return 'variant-clinical-samples';
            }

            static get properties() {
                return {
                    opencgaClient: {
                        type: Object,
                        observer: "renderAnalysisTable"
                    },
                    project: {
                        type: Object
                    },
                    study: {
                        type: Object
                    },
                    samples: {
                        type: Array,
                        notify: true
                    },
                    prefix: {
                        type: String
                    },
                    filters: {
                        type: Object,
                        notify: true,
                        observer: "onFilterUpdate"
                    },
                    search: {
                        type: Object,
                        notify: true
                    },
                    config: {
                        type: Object
                    },
                    showMessageModal: {
                        type: Boolean,
                        notify: true
                    },
                    settingsMessageModal: {
                        type: Object,
                        notify: true
                    },
                    analysisChanged: {
                        type: Number,
                        observer: "renderAnalysisTable"
                    }
                }
            }

            _attachDom(dom) {
                this.appendChild(dom);
            }

            ready() {
                super.ready();

                this._numAnalysisSelected = 0;
                this.analysisChanged = 0;
                this.currentAnalysis = {};
                this.selectedRow = -1;
                this.unsavedAnalysis = 0;
                this.messageError = false;
                this.fixedFilters = ["studies"];
            }

            static get observers() {
                return ['calculateFilters(filteredVariables.variables.*)'];
            }

            renderAnalysisTable() {
                let _this = this;
                $(PolymerUtils.getElementById(this.prefix + "tableAnalysis")).bootstrapTable('destroy');
                $(PolymerUtils.getElementById(this.prefix + "tableAnalysis")).bootstrapTable({
                    columns: _this._getClinicalAnalysisColumns(),
                    data: _this._analysis,
                    onCheck: function (row, elem) {
                        PolymerUtils.removeClass(_this.prefix + 'DeleteAnalysisButton', 'disabled');
                        _this._numAnalysisSelected++;
                    },
                    onUncheck: function (row, elem) {
                        _this._numAnalysisSelected--;
                        if (_this._numAnalysisSelected <= 0) {
                            PolymerUtils.addClass(_this.prefix + 'DeleteAnalysisButton', 'disabled');
                        }
                    },
                    onClickCell: function (field, value, row, elem) {
                        if (field === "editFamily") { // Only if cell related to family editor is selected, get samples for this analysis to the family editor
                            _this._samplesAnalysis = row.sampleList;
                            _this.currentAnalysis = row;
                            _this.selectedRow = elem.parent().data("index");
                            if (UtilsNew.isNotUndefinedOrNull(row.family)) {
                                _this.family = row.family;
                            } else {
                                _this.initFamily();
                            }

                        } else if (field === "action") { // Only if cell related to save is selected
                            _this.saveAnalysis(row);
                        }
                    }
                });
            }

            initFamily() {
                if (UtilsNew.isNotUndefinedOrNull(this._samplesAnalysis)) {
                    this.family = {};
                    this.family.name = "FA-" + Math.floor(Math.random() * 10000) + 1;
                    this.family.description = "";
                    this.family.diseases = [];
                    this.family.members = [];
                    this.family.annotationSets = [];
//                    this.family.createDate = new Date();
                    this.family.attributes = {};
                    let _this = this;
                    this._samplesAnalysis.forEach((sample) => {
                        _this.family.members[sample.id] = {
                            father: undefined,
                            mother: undefined,
                            ontologyTerms: [],
//                            multiples: [],
//                            samples: [],
                            parentalConsanguinity: false
                        }
                    });
                }
            }

            connectedCallback() {
                super.connectedCallback();

                this.table = PolymerUtils.getElementById(this.prefix + "FamilySelector");
                this.renderAnalysisTable();
                let _this = this;
                $("#"+this.prefix + "FamilyEditor").on('shown.bs.modal', function (e) {
                    _this.showModalFamilyEditor = true;
                });

                $("#"+this.prefix + "FamilyEditor").on('hidden.bs.modal', function() {
                    _this.showModalFamilyEditor = false;
                });
            }

            /**
             * If filters have been removed, clean the values from the forms.
             */
            onFilterUpdate() {
                this.updateForms(this.filters);
            }

            updateForms(filters) {
                // This is just to avoid entering here when it has just been initialized
                if (this.prefix === undefined) {
                    return;
                }

                let sampleName = PolymerUtils.getElementById(this.prefix + "NameTextarea").value;
                if (!filters.hasOwnProperty("name") && sampleName !== undefined && sampleName.length > 0) {
                    PolymerUtils.setPropertyById(this.prefix + "NameTextarea", "value", "");
                }

                let individual = PolymerUtils.getElementById(this.prefix + "IndividualTextarea").value;
                if (!filters.hasOwnProperty("individual.id") && individual !== undefined && individual.length > 0) {
                    PolymerUtils.setPropertyById(this.prefix + "IndividualTextarea", "value", "");
                }

                if (this.filteredVariables.variables.length > 0) {
                    if (!filters.hasOwnProperty("annotation")) {
                        this.set("filteredVariables.variables", []);
                    } else if (filters.annotation.length < this.filteredVariables.variables.length) {
                        let tmpVariables = [];
                        filters.annotation.forEach(function (variable) {
                            tmpVariables.push(variable);
                        });

                        this.set("filteredVariables.variables", tmpVariables);
                    }
                }
            }

            /**
             * Read from the values in the forms, and sets the filters.
             */
            calculateFilters() {
                let filters = {};
                let sampleName = "";
                let individual = "";

                if (PolymerUtils.getElementById(this.prefix + "NameTextarea") !== null) {
                    sampleName = PolymerUtils.setPropertyById(this.prefix + "NameTextarea", "value", "");

                }
                if (PolymerUtils.getElementById(this.prefix + "IndividualTextarea") !== null) {
                    individual = PolymerUtils.setPropertyById(this.prefix + "IndividualTextarea", "value", "");
                }

                if (sampleName !== undefined && sampleName.length > 0) {
                    filters["name"] = "~" + sampleName;
                }

                if (individual !== undefined && individual.length > 0) {
                    filters["individual.id"] = "~" + individual;
                }

                if (this.filteredVariables.variables !== undefined && this.filteredVariables.variables.length > 0) {
                    let annotations = [];
                    this.filteredVariables.variables.forEach(function (variable) {
                        annotations.push(variable);
                    });
                    filters["annotation"] = annotations;
                }
                this.filters = filters;
            }

            onSearch() {
                // Convert the filters to an objectParam that can be directly send to the sample search
                let filterParams = {};

                let keys = Object.keys(this.filters);
                for (let i = 0; i < keys.length; i++) {
                    if (Array.isArray(this.filters[keys[i]])) {
                        let myArray = this.filters[keys[i]];

                        let myArrayFilter = [];

                        // The elements in the array can be either an object
                        if (Object.getPrototypeOf(myArray[0]) === Object.prototype) {
                            let myArray = this.filters[keys[i]];
                            for (let j = 0; j < myArray.length; j++) {
                                // TODO: We have to check if the value already has an operand
                                myArrayFilter.push(myArray[j].name + "=" + myArray[j].value);
                            }
                        } else {
                            // Or an array of strings or numbers
                            myArrayFilter = this.filters[keys[i]];
                        }

                        filterParams[keys[i]] = myArrayFilter.join(";");
                    } else {
                        filterParams[keys[i]] = this.filters[keys[i]];
                    }
                }

                if (this.filters.hasOwnProperty("annotation")) {
                    // Add the variable set whose annotations will be queried
                    filterParams["variableSetId"] = this.filteredVariables.variableSet;
                }
                this.search = filterParams;
            }

            addAnalysis(e) {

                e.preventDefault(); // prevents the hash change to "#" and allows to manipulate the hash fragment as needed
                let analysisId = Math.floor(Math.random() * 10000) + 1;
                // Get the type of analysisId
                let analysisType = "";
                let _properMembers = -1;
                let _familyEditor = false;
                this.family = {};


                switch (e.currentTarget.id) {
                    case "familyButton":
                        analysisType = "Family";
                        _properMembers = 4;
                        _familyEditor = true;
                        break;
                    case "trioButton":
                        analysisType = "Trio";
                        _properMembers = 3;
                        _familyEditor = true;
                        break;
                    case "duoButton":
                        analysisType = "Duo";
                        _properMembers = 2;
                        _familyEditor = true;
                        break;
                    case "singleButton":
                        analysisType = "Single";
                        _properMembers = 1;
                        _familyEditor = true;
                        break;
                    case "autoButton":
                        analysisType = "Auto comparative";
                        _properMembers = 2;
                        break;
                    case "multiButton":
                        analysisType = "Multisample";
                        _properMembers = 2;
                        break;
                    default:
                        analysisType = "Family";
                        _properMembers = 4;
                        break;
                }


               if (this.analysisError(analysisType, this.samples.length, _properMembers, this.samples)) {
                    let fullDate = new Date();
                    let twoDigitMonth = ((fullDate.getMonth().length + 1) === 1) ? (fullDate.getMonth() + 1) : '0' + (fullDate.getMonth() + 1);
                    let currentDate = fullDate.getDate() + "/" + twoDigitMonth + "/" + fullDate.getFullYear();

                    let samplesToShow = "";

                    for (let sampleIdx in this.samples) {
                        samplesToShow = samplesToShow + this.samples[sampleIdx].name + ",";
                    }
                    samplesToShow = samplesToShow.slice(0, -1);

                    let _this = this;

                    // Add analysis to property analysis so that can be used in prioritization
                    // This code will be removed as soon as analysis can be saved

                    let aux = Utils.randomString(6);

                    let _anObject = {
                        analysisID: _this.analysisFormatter("AN-" + analysisId, aux),
                        analysisSamples: samplesToShow,
                        analysisType: analysisType,
                        analysisDate: currentDate,
                        filter: "NO",
                        editFamily: _this.familyFormatter(_familyEditor, aux),
                        subjectSelected: _this.subjectFormatter(aux, ""),
                        diseaseSelected: _this.diseaseFormatter(aux, ""),
                        action: _this.actionFormatter(_familyEditor, aux),
                        sampleList: this.samples,
                        analysisIDinternal: aux,
                        family: null
                    };

                    if (UtilsNew.isNotUndefined(this._analysis)) {
                        this.push('_analysis', _anObject);
                    }
                    else {
                        this._analysis = [_anObject];
                    }
                    this.analysisChanged++;
                    this.unsavedAnalysis++;
                }
            }

            deleteAnalysis(e) {
                e.preventDefault(); // prevents the hash change to "#" and allows to manipulate the hash fragment as needed
                let ids = $.map($(PolymerUtils.getElementById(this.prefix + 'tableAnalysis')).bootstrapTable('getSelections'), function (row) {
                    return row.analysisID;
                });

                $(PolymerUtils.getElementById(this.prefix + 'tableAnalysis')).bootstrapTable('remove', {
                    field: 'analysisID',
                    values: ids
                });
                this.unsavedAnalysis--;
            }

            saveAnalysis(rowInfo) {
                if (this.opencgaClient instanceof OpenCGAClient) {

                    let _analysisType = "";
                    this.messageErrorText = "";
                    this.messageSuccessText = "";
                    this.messageError = false;
                    this.messageSuccess = false;
                    switch (rowInfo.analysisType) {
                        case "Single":
                            _analysisType = "SINGLE";
                            break;
                        case "Duo":
                            _analysisType = "DUO";
                            break;
                        case "Trio":
                            _analysisType = "TRIO";
                            break;
                        case "Family":
                            _analysisType = "FAMILY";
                            break;
                        case "Auto comparative":
                            _analysisType = "AUTO";
                            break;
                        case "Multisample":
                            _analysisType = "MULTISAMPLE";
                            break;
                    }
                    let params = {
                        study: this.project.alias + ":" + this.study.alias
                    };
                    let bodyFamily = null;


                    bodyFamily = Object.assign({}, rowInfo.family);
                    let membersNew = [];

                    bodyFamily.members.forEach((member) => {
                        let newMember = Object.assign(member);
                        membersNew.push(member);
                    });
                    bodyFamily.members = membersNew;
                    let membersWithParents = bodyFamily.members.filter((member) => {
                        return UtilsNew.isNotUndefinedOrNull(member.father) && UtilsNew.isNotUndefinedOrNull(member.mother);
                    });

                    let individualPromises = [];
                    let checkPromises = [];
                    let _this = this;
                    let subjectName = "";
                    let samplesName = [];
                    let diseaseAnalysis
                    let subjects = [];

                    // These properties are for analysis
                    subjectName = PolymerUtils.getValue(this.prefix + "selectedSubject" + rowInfo.analysisIDinternal);
                    samplesName = rowInfo.sampleList.filter((sample) => {
                        return sample.individual.name === subjectName;
                    }).map((sample) => {
                        let res = {name: sample.name};
                        return res;
                    });
                    diseaseAnalysis = rowInfo.family.diseases.find((disease)=> {
                        return disease.id === PolymerUtils.getValue(this.prefix + "selectedDisease" + rowInfo.analysisIDinternal);
                    });
                    subjects.push({name: subjectName, samples:samplesName});

                    let analysisInfo = {
                        analysisID: rowInfo.analysisID,
                        type: _analysisType,
                        familyID: rowInfo.family !== null ? rowInfo.family.name : "",
                        subjects:  subjects,
                        disease: diseaseAnalysis
                    };

                    // Check if already exists an analysis or family with current names
                    let checkExistsNames = true;
                    let checkFamilyName = _this.opencgaClient.families().search(Object.assign({name: bodyFamily.name}, params), {"method": "GET"})
                        .then(function(response){
                            if (response.response[0].numResults >= 1 || UtilsNew.isUndefinedOrNull(bodyFamily.name) || UtilsNew.isEmpty(bodyFamily.name)) {
                                checkExistsNames = false;
                            }
                        });
                    checkPromises.push(checkFamilyName);
                    let checkAnalysisName = _this.opencgaClient.clinical().search(Object.assign({name: analysisInfo.analysisID}, params), {"method": "GET"})
                        .then(function(response){
                            if (response.response[0].numResults >= 1 || UtilsNew.isUndefinedOrNull(analysisInfo.analysisID) || UtilsNew.isEmpty(analysisInfo.analysisID)) {
                                checkExistsNames = false;
                            }
                        });
                    checkPromises.push(checkAnalysisName);


                    // Once all checkExistsName promise are resolved we try to create family
                    Promise.all(checkPromises)
                        .then(function (response) {
                            if(checkExistsNames){
                                if(membersWithParents.length > 0) {
                                    membersWithParents.forEach(function (individualToUpdate) {
                                        _this.opencgaClient.individuals().info(individualToUpdate.name, params, {"method": "GET"})
                                            .then(function (response) {
                                                if (response.response[0].numResults >= 1) {
                                                    let individual = response.response[0].result[0];
                                                    let individualId = individual.id;

                                                    // Check if individual has father or mother already. If individual does not have, we will allow create family.
                                                    if ((UtilsNew.isUndefinedOrNull(individual.father) && UtilsNew.isUndefinedOrNull(individual.mother)) ||
                                                        (UtilsNew.isUndefinedOrNull(individual.father.id) && UtilsNew.isUndefinedOrNull(individual.mother.id)) ||
                                                        (individual.father.id <= 0 && individual.mother.id <= 0)) {
                                                        let individualPost = {
                                                            father: individualToUpdate.father,
                                                            mother: individualToUpdate.mother
                                                        };
                                                        let individualPromise = _this.opencgaClient.individuals().update(individualId, params, individualPost, {"method": "POST"})
                                                            .then(function (response) {
                                                                console.log("Individual update");
                                                            });
                                                        individualPromises.push(individualPromise);
                                                        Promise.all(individualPromises)
                                                            .then(function (response) {
                                                                console.log("Create family");
                                                                if ((_analysisType !== "TRIO" && _analysisType !== "FAMILY") || UtilsNew.isNotUndefinedOrNull(individualPromises) &&
                                                                    UtilsNew.isNotEmptyArray(individualPromises) && individualPromises.length > 0) {
                                                                    _this.createFamily(params, bodyFamily, rowInfo, subjectName, samplesName, analysisInfo);
                                                                } else {
                                                                    _this.messageError = true;
                                                                    _this.messageErrorText = "We cannot create a family. Individuals are not correct.";
                                                                    PolymerUtils.innerHTML(_this.prefix + "messageError", _this.messageErrorText);
                                                                }
                                                            })
                                                            .catch(function (response) {
                                                                _this.messageError = true;
                                                                _this.messageErrorText = response.error;
                                                                PolymerUtils.innerHTML(_this.prefix + "messageError", _this.messageErrorText);
//                                                                _this.settingsMessageModal = {
//                                                                    messageHeader: "Error",
//                                                                    messageBody: [response.error],
//                                                                    type: "danger",
//                                                                    height: "100px",
//                                                                    width: "500px"
//                                                                };
//                                                                _this.set('settingsMessageModal', _this.settingsMessageModal);
//                                                                _this.showMessageModal = true;
                                                            });
                                                    } else {
                                                        _this.messageError = true;
                                                        _this.messageErrorText = individualToUpdate.name +" individual already has parents.";
                                                        PolymerUtils.innerHTML(_this.prefix + "messageError", _this.messageErrorText);
                                                    }
                                                }

                                            });
                                    });
                                }else{
                                    if((_analysisType !== "TRIO" && _analysisType !== "FAMILY") || UtilsNew.isNotUndefinedOrNull(individualPromises) &&
                                        UtilsNew.isNotEmptyArray(individualPromises) && individualPromises.length > 0) {
                                        _this.createFamily(params, bodyFamily, rowInfo, subjectName, samplesName, analysisInfo);
                                    }  else {
                                        _this.messageError = true;
                                        _this.messageErrorText = "We cannot create a family. Analysis type is not correct.";
                                        PolymerUtils.innerHTML(_this.prefix + "messageError", _this.messageErrorText);
                                    }
                                }


                            }else{
                                //@TODO Show message warning with name duplicate
                                _this.messageError = true;
                                _this.messageErrorText = "Family name or Analysis name is not correct.";
                                PolymerUtils.innerHTML(_this.prefix + "messageError", _this.messageErrorText);
                            }
                        });
                }
            }

            createFamily(params, body, rowInfo, subjectName, samplesName, analysisInfo){
                let _this = this;
                this.opencgaClient.families().create(params, body)
                    .then(function (response) {
                        if (response.response[0].numResults >= 1) {
                            _this.createAnalysis(analysisInfo);
                        }
                    })
                    .catch(function (response) {
                        _this.messageError = true;
                        _this.messageErrorText = response.error;
                        PolymerUtils.innerHTML(_this.prefix + "messageError", _this.messageErrorText);
//                        _this.settingsMessageModal = {
//                            messageHeader: "Error",
//                            messageBody: [response.error],
//                            type: "danger",
//                            height: "100px",
//                            width: "500px"
//                        };
//
//                        _this.showMessageModal = true;
                    });
            }

            createAnalysis(analysisInfo) {
                let params = {
                    study: this.project.alias + ":" + this.study.alias
                };
                let body = {
                    "name": analysisInfo.analysisID,
                    "type": analysisInfo.type,
                    "family": analysisInfo.familyID,
                    "subjects": analysisInfo.subjects,
                    "disease": analysisInfo.disease,
//                    "sample": analysisInfo.sample,
                    "attributes": {
                        "filter": false
                    }
                };
                let _this = this;
                this.opencgaClient.clinical().create(params, body)
                    .then(function (response) {
                        _this.unsavedAnalysis--;
                        _this.messageSuccess = true;
                        _this.messageSuccessText = body.name + " analysis has been created correctly.";
                        PolymerUtils.innerHTML(_this.prefix + "messageSuccess", _this.messageSuccessText);
                    })
                    .catch(function (response) {
                        _this.messageError = true;
                        _this.messageErrorText = response.error;
                        PolymerUtils.innerHTML(_this.prefix + "messageError", _this.messageErrorText);
//                        _this.settingsMessageModal = {
//                            messageHeader: "Error",
//                            messageBody: [response.error],
//                            type: "danger",
//                            height: "100px",
//                            width: "500px"
//                        };
//                        _this.showMessageModal = true;
                    });
            }

            familyFormatter(familyEditor, randomString) {
                if (familyEditor) {
                    return '<button data-toggle="modal" id="' + this.prefix + 'Editor' + randomString + '" role="button" type="button" class="btn btn-sm btn-success" data-target="#' + this.prefix + 'FamilyEditor" ><i class="fa fa-cog" aria-hidden="true"></i>&nbsp;Edit</button>';
                } else { // Is not a family analysis -> a family cannot be edited
                    return '<button data-toggle="modal" id="' + this.prefix + 'Editor' + randomString + '" role="button" type="button" class="btn btn-sm btn-success disabled" disabled data-target="#' + this.prefix + 'FamilyEditor"><i class="fa fa-cog" aria-hidden="true"></i>&nbsp;Edit</button>';
                }
            }
            subjectFormatter(randomString, selected) {
                let res = "NO AFFECTED";
                if (UtilsNew.isNotUndefinedOrNull(this.family) && UtilsNew.isNotUndefinedOrNull(this.family.members)) {

                    let affectedMembers = this.family.members.filter((member) => {
                        return UtilsNew.isNotUndefinedOrNull(member.ontologyTerms) && member.ontologyTerms.length > 0;
                    });

                    res = '<select id='+ this.prefix + 'selectedSubject' + this.currentAnalysis.analysisIDinternal + ' class="form-control form-control-sm">';
                    affectedMembers.forEach((affected) => {
                        if (selected === affected.name) {
                            res = res +  '<option value="'+affected.name+'" selected>'+affected.name+'</option>';
                        } else {
                            res = res +  '<option value="'+affected.name+'">'+affected.name+'</option>';
                        }
                    });
                    res = res +'</select>';
                }
                return res;
            }

            diseaseFormatter(randomString, selected) {
                let res = "NOT DISEASES";
                let _this = this;
                if (UtilsNew.isNotUndefinedOrNull(this.family) && UtilsNew.isNotUndefinedOrNull(this.family.diseases)) {
                    let resDiseases = [];
                    let affectedMembers = [];
                    affectedMembers = this.family.members.filter((member) => {
                        return UtilsNew.isNotUndefinedOrNull(member.ontologyTerms) && member.ontologyTerms.length > 0;
                    });

                    affectedMembers.forEach((affectedMember) => {
                        affectedMember.ontologyTerms.forEach((diseaseMember) => {
                            let existsDiseaseInRes = resDiseases.find((disease) => {
                                return disease.id === diseaseMember.id;
                            });

                            if(UtilsNew.isUndefinedOrNull(existsDiseaseInRes)){
                                let selectedDisease =_this.family.diseases.find((disease) => {
                                    return disease.id === diseaseMember.id;
                                });

                                if(UtilsNew.isNotUndefinedOrNull(selectedDisease)){
                                    resDiseases.push(selectedDisease);
                                }
                            }
                        });
                    });

                    res = '<select id='+ this.prefix + 'selectedDisease' + this.currentAnalysis.analysisIDinternal + ' class="form-control form-control-sm">';
                    resDiseases.forEach((disease) => {
                        if(selected === disease.id){
                            res = res +  '<option value="'+disease.id+'" selected>'+disease.id+'</option>';
                        }else{
                            res = res +  '<option value="'+disease.id+'">'+disease.id+'</option>';
                        }
                    });
                    res = res +'</select>';
                }
                return res;
            }

            actionFormatter(familyEditor, randomString) {
                if (familyEditor) {
                    return '<button type="button" id="' + this.prefix + 'Save' + randomString + '" class="btn btn-sm btn-primary disabled" disabled><i class="fa fa-floppy-o" aria-hidden="true"></i>&nbsp;Save</button>';
                }
                else { // If not a family analysis, such analysis can be saved inmediatly
                    return '<button type="button" id="' + this.prefix + 'Save' + randomString + '" class="btn btn-sm btn-primary"><i class="fa fa-floppy-o" aria-hidden="true"></i>&nbsp;Save</button>';
                }
            }

            analysisFormatter(analysisID, randomString) {
//                return '<input type="text" id="' + this.prefix + 'analysisID' + randomString + '" class="form-control" value="' + analysisID + '" maxlength="75">';
                return analysisID;
            }

            analysisError(analysisType, introducedLength, properLength, samples) {
                if ((analysisType === 'Trio' || analysisType === 'Duo' || analysisType === 'Single' || analysisType === 'Auto comparative') && introducedLength != properLength) {
                    PolymerUtils.innerHTML(this.prefix + "warningMsgDiv", "Incorrect number of samples selected (" + introducedLength.toString() + ") for " + analysisType + " analysis (" + properLength.toString() + ")");
                    $(PolymerUtils.getElementById(this.prefix + "warningModal")).modal('show');
                    return false;
                } else if ((analysisType === 'Family' || analysisType === 'Multisample') && introducedLength < properLength) {
                    PolymerUtils.innerHTML(this.prefix + "warningMsgDiv", "Incorrect number of samples selected (" + introducedLength.toString() + ") for " + analysisType + " analysis (at least " + properLength.toString() + ")");
                    $(PolymerUtils.getElementById(this.prefix + "warningModal")).modal('show');
                    return false;
                } else if(analysisType === "Single" && UtilsNew.isNotUndefinedOrNull(samples[0]) && UtilsNew.isEmptyArray(samples[0].ontologyTerms)) {
                    PolymerUtils.innerHTML(this.prefix + "warningMsgDiv", "Incorrect single analysis without diseases");
                    $(PolymerUtils.getElementById(this.prefix + "warningModal")).modal('show');
                    return false;
                } else {
                    return true;
                }
            }

            selectSubject(e){
                PolymerUtils.setValue(this.prefix + "selectedSubject" + this.currentAnalysis.analysisIDinternal, e.target.value);
            }

            familyChange(e, family) { // Event fired by opencga-family-editor web component
                this.family = family;
            }

            checkFamily(e) {
                e.preventDefault();

                let _this = this;

                // We have to do this before updateRow to get the selectedValue in member select. Instead we will get the first value of the all options
                let subjectSelected = PolymerUtils.getValue(this.prefix + "selectedSubject" + this.currentAnalysis.analysisIDinternal);
                let diseaseSelected = PolymerUtils.getValue(this.prefix + "selectedDisease" + this.currentAnalysis.analysisIDinternal);
                $(PolymerUtils.getElementById(this.prefix + "tableAnalysis")).bootstrapTable('updateRow', {
                    index: _this.selectedRow, row: {
                        family: _this.family,
                        samples: _this.samples
                    }
                });
                $(PolymerUtils.getElementById(this.prefix + "tableAnalysis")).bootstrapTable("updateCell",{ index: _this.selectedRow, field: "subjectSelected", value: _this.subjectFormatter(this.currentAnalysis.analysisIDinternal, subjectSelected)});
                $(PolymerUtils.getElementById(this.prefix + "tableAnalysis")).bootstrapTable("updateCell",{ index: _this.selectedRow, field: "diseaseSelected", value: _this.diseaseFormatter(this.currentAnalysis.analysisIDinternal, diseaseSelected)});
                PolymerUtils.getElementById(this.prefix + 'selectedSubject' + this.currentAnalysis.analysisIDinternal).addEventListener('change', e => this.selectSubject(e));
                PolymerUtils.removeAttribute(this.prefix + "Save" + this.currentAnalysis.analysisIDinternal, "disabled");
                PolymerUtils.removeClass(this.prefix + "Save" + this.currentAnalysis.analysisIDinternal, "disabled");
            }

            _getClinicalAnalysisColumns() {
                return [
                    [
                        {
                            field: 'state',
                            checkbox: true,
                            align: 'center',
                            valign: 'middle'
                        },
                        {
                            field: 'analysisID',
                            title: 'Analysis ID'
                        },
                        {
                            field: 'analysisSamples',
                            title: 'Samples'
                        },
                        {
                            field: 'analysisType',
                            title: 'Analysis Type'
                        },
                        {
                            field: 'editFamily',
                            title: 'Definition'
                        },
                        {
                            field: 'analysisDate',
                            title: 'Date'
                        },
                        {
                            field: 'subjectSelected',
                            title: 'Subject'
                        },
                        {
                            field: 'diseaseSelected',
                            title: 'Disease'
                        },
                        {
                            field: 'action',
                            title: 'Action'
                        },
                        {
                            field: 'sampleList',
                            visible: false
                        },
                        {
                            field: 'analysisIDinternal',
                            visible: false
                        },
                        {
                            field: 'family',
                            visible: false
                        }
                    ]
                ];
            }

            onClear() {
                this.query = {studies: this.project.alias + ":" + this.study.alias};
                this.search = {};
            }

            onFilterChange(e) {
                this.query = e.detail;
                this.search = e.detail;
            }
        }

        customElements.define(VariantClinicalSamples.is, VariantClinicalSamples);
    </script>
</dom-module>
