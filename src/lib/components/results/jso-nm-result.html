<polymer-element name="jso-nm-result" attributes="jobItem">
<template>
    <link rel="stylesheet" href="../jso-style.css">
    <link rel="stylesheet" href="../sortable-table.css">
    <style>
        :host {
            display: block;
            /*position: relative;*/
            background-color: white;
        }

        sortable-table {
        }

    </style>
    <!--<span>{{jobItem.id}}</span>-->
    <!--<span>{{jobItem.outDir}}</span>-->

    <div id="output">
    </div>

</template>
<script>
Polymer({
    created: function () {
        this.fileId = -1
        this.elements = new Array();
    },
    jobItemChanged: function (oldV, newV) {
        var me = this;

        OpencgaManager.files.filesByFolder({
            id: me.jobItem.outDirId,
            query: {
                sid: Cookies("bioinfo_sid")
            },
            request: {
                success: function (response) {

                    if (response.response[0].errorMsg === '' || response.response[0].errorMsg == null) {
                        me.filesList = response.response[0].result;
                        me.getFileContent(function (content) {
                            var root = me.$.output;
                            me.parseXML(content, root);
                        }, "result.xml");
                    }
                },
                error: function () {
                    me.message = 'Server error, try again later.';
                }
            }
        })
    },
    getFileContent: function (callback, fileName) {
        var me = this;
        var fileId = -1;
        for (var result in this.filesList) {
            if (this.filesList[result].name == fileName) {
                fileId = this.filesList[result].id
                break;
            }
        }
        OpencgaManager.files.content({
            id: fileId,
            query: {
                sid: Cookies("bioinfo_sid")
            },
            request: {
                success: function (response) {
//                    var content = response.response[0]
                    /** I pass localDiv as parameter because I loose the div to render in a loop **/
                    callback(response)
                },
                error: function () {
                    this.message = 'Server error, try again later.';
                }
            }
        })
    },
    parseXML: function (xml, root) {
        var me = this;
        if (window.DOMParser) {
            var parser = new DOMParser();
            var xmlDoc = parser.parseFromString(xml, "text/xml");
            /** Parse XML **/
            var output = xmlDoc.getElementsByTagName("output")[0].children

            /** Create HTML structure **/
            var i = 0;
            var webStructure = new Object();
            output.array().forEach(function (childNode) {
//                var childNode = output[i];
                var nameInput = childNode.getAttribute("name");
                var divId = nameInput + "_" + i;
                me.createHtmlElement("div", divId);
                i++;
            });
            /** Fill HTML elements **/
            var groups = [];
//            for (var i = 0; i < output.length; i++) {
            i = 0;
            output.array().forEach(function (childNode) {

                var nameInput = childNode.getAttribute("name");
                var titleInput = childNode.getAttribute("title");
                var typeInput = childNode.getAttribute("type");
                var groupInput = childNode.getAttribute("group");
                var tagsInput = childNode.getAttribute("tags");
                var valueInput = childNode.firstChild.nodeValue;

                var divId = nameInput + "_" + i;
                i++;
//                var element = me.$.output.querySelector("#" + divId);
                var element = root.querySelector("#" + divId);
                /** Create headers **/
                if (!(groupInput in groups)) {
                    groups[groupInput] = true;
                    if (groupInput.indexOf(".") > 0) {
                        groupInput = groupInput.split(".");
                        me.createHeader(element, "h2", groupInput[0]);
                        me.createHeader(element, "h3", groupInput[1]);
                    }
                    else {
                        me.createHeader(element, "h2", groupInput);
                    }
                }
                if (typeInput == "MESSAGE" || typeInput == "FILE" || typeInput == "TEXT") {
                    me.createHeader(element, "div", titleInput + ": " + valueInput);
                }
//
                if (typeInput == "IMAGE") {
                    me.getFileContent(function (content) {
                        me.parseImage(content, tagsInput, divId);
                    }, valueInput);
                }
//                if(typeInput == "IMAGE_STATIC"){
//                    for (var result in this.filesList) {
//                        if (this.filesList[result].name == fileName) {
//                            fileId = this.filesList[result].id
//                            break;
//                        }
//                    }
//                    var imageUrl = OpencgaManager.files.content({
//                        id: fileId,
//                        query: {
//                            sid: Cookies("bioinfo_sid")
//                        },
//                        request: {
//                            url:true
//                        }
//                    })
//                }
                if (typeInput == "FILE") {
                    me.getFileContent(function (content) {
                        me.parseTable(content, tagsInput, divId);
                    }, valueInput);
                }

            })
        }
        else // Internet Explorer
        {
            var xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
            xmlDoc.async = false;
            xmlDoc.loadXML(xml);
        }
    },
    createHtmlElement: function (htmlType, id) {
        var el = document.createElement(htmlType);
        el.id = id;
//        var node = document.createTextNode(htmlContent);
//        header.appendChild(node);
        this.$.output.appendChild(el);
    },
    createHeader: function (father, htmlType, htmlContent) {
        var el = document.createElement(htmlType);
        var node = document.createTextNode(htmlContent);
        el.appendChild(node);
        father.appendChild(el);
//        this.$.output.appendChild(father);
    },
    parseTable: function (content, tags, divId) {
        var me = this;
        if (tags.indexOf("NETWORKMINERRANKED_TABLE") > 0) {
            var data = content.split("\n");
//            var header = data[0].split("\t")

            var sortableTable = document.createElement('sortable-table');
            sortableTable.setAttribute("id", "tableId");
            var dataArray = new Array();
            for (var i = 1; i < data.length; i++) {
                dataArray.push(data[i].split("\t"))
            }

            sortableTable.columns = ["Input", "Id", "Type", "Rank", "Betweenness", "Clustering", "Connections", "GOs", "KEEGs"];
            sortableTable.data = dataArray;
            sortableTable.pageSize = "10"
            sortableTable.footerTemplate = "simplePager"
            this.$.output.querySelector("#" + divId).appendChild(sortableTable);
        }
        if (tags.indexOf("INTERACTOME_VIEWER") >= 0) {
            var networkViewer = document.createElement('jso-network-viewer');
            networkViewer.setAttribute("id", "networkId");
            var adapter = new SIFNetworkDataAdapter({
                dataSource: new StringDataSource(content),
                handlers: {
                    'data:load': function (event) {
                        //me.processData(event.graph);
                        networkViewer.setGraph(event.graph);
                        networkViewer.setLayout("Force directed");
                        me.$.output.querySelector("#" + divId).appendChild(networkViewer);
                    },
                    'error:parse': function (event) {
                        console.log("ERRORRRR");
                    }
                }
            });

        }

    },
    parseImage: function (content, tags, divId) {
        if (tags.indexOf("NETWORKMINER_JSON") >= 0) {
            this.parseHighCharts(content, divId);
        }
        return content;

    },
    parseHighCharts: function (content, divId) {
        var json = JSON.parse(content);

        /** Create HTML elements **/
        var elSizeAvg = document.createElement("div");
        elSizeAvg.id = divId + "_avg";
        this.$.output.querySelector("#" + divId).appendChild(elSizeAvg);

        var elSizeScore = document.createElement("div");
        elSizeScore.id = divId + "_score";
        this.$.output.querySelector("#" + divId).appendChild(elSizeScore);

        /** Create data for charts **/
        var sizeAvgList = new Array();
        var sizeAvgListSig = new Array();

        var sizeScoreList = new Array();
        var sizeScoreListSig = new Array();

        for (var idx = 0; idx < json.length; idx++) {
            var j = json[idx];
            var nodesLength = j.nodes.length;
            var rawValue = j.rawValue;
            var score = j.score;
            var itemsSizeAvg = new Array();
            var itemsSizeScore = new Array();

            itemsSizeAvg.push(nodesLength);
            itemsSizeAvg.push(rawValue);

            itemsSizeScore.push(nodesLength);
            itemsSizeScore.push(score);

            if (!j.significant) {
                sizeAvgList.push(itemsSizeAvg);
                sizeScoreList.push(itemsSizeScore);
            }
            else {
                sizeAvgListSig.push(itemsSizeAvg);
                sizeScoreListSig.push(itemsSizeScore);
            }
        }
        new Highcharts.Chart({
            chart: {
                renderTo: this.$.output.querySelector("#" + elSizeAvg.id),
                type: 'scatter',
                zoomType: 'xy',
                width: 800
            },
            title: {
                text: 'Size vs. Avg. node per component'
            },
            xAxis: {
                title: {
                    enabled: true,
                    text: 'Size'
                },
                startOnTick: true,
                endOnTick: true,
                showLastLabel: true
            },
            yAxis: {
                title: {
                    text: 'Avg. node per component'
                }
            },
            plotOptions: {
                scatter: {
                    marker: {
                        radius: 5,
                        states: {
                            hover: {
                                enabled: true,
                                lineColor: 'rgb(100,100,100)'
                            }
                        }
                    },
                    states: {
                        hover: {
                            marker: {
                                enabled: false
                            }
                        }
                    },
                    tooltip: {
                        headerFormat: '<b>{series.name}</b><br>',
                        pointFormat: '{point.x} , {point.y} '
                    }
                }
            },
            series: [
                {
                    name: 'Size / Avg. node per component',
                    color: 'rgba(119, 152, 191, .5)',
                    data: sizeAvgList
                },
                {
                    name: 'Selected',
                    color: 'rgba(223, 83, 83, .5)',
                    data: sizeAvgListSig

                }
            ]
        });
        new Highcharts.Chart({
            chart: {
                renderTo: this.$.output.querySelector("#" + elSizeScore.id),
                type: 'scatter',
                zoomType: 'xy',
                width: 800
            },
            title: {
                text: 'Size vs. Score'
            },
            xAxis: {
                title: {
                    enabled: true,
                    text: 'Size'
                },
                startOnTick: true,
                endOnTick: true,
                showLastLabel: true
            },
            yAxis: {
                title: {
                    text: 'Score'
                }
            },
            plotOptions: {
                scatter: {
                    marker: {
                        radius: 5,
                        states: {
                            hover: {
                                enabled: true,
                                lineColor: 'rgb(100,100,100)'
                            }
                        }
                    },
                    states: {
                        hover: {
                            marker: {
                                enabled: false
                            }
                        }
                    },
                    tooltip: {
                        headerFormat: '<b>{series.name}</b><br>',
                        pointFormat: '{point.x} , {point.y} '
                    }
                }
            },
            series: [
                {
                    name: 'Size / Score',
                    color: 'rgba(119, 152, 191, .5)',
                    data: sizeScoreList
                },
                {
                    name: 'Selected',
                    color: 'rgba(223, 83, 83, .5)',
                    data: sizeScoreListSig

                }
            ]
        });


    }

});
</script>
</polymer-element>


