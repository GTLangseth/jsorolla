<link rel="import" href="jso-nv-edition-bar.html">
<link rel="import" href="jso-nv-tool-bar.html">
<link rel="import" href="jso-nv-status-bar.html">
<link rel="import" href="jso-nv-layout.html">

<script src="../lib/svg.js"></script>
<script src="../lib/utils.js"></script>

<script src="../lib/network/attributes/attribute-manager-memory.js"></script>
<script src="../lib/network/network.js"></script>
<script src="../lib/network/graph.js"></script>
<script src="../lib/network/point.js"></script>
<script src="../lib/network/edge.js"></script>
<script src="../lib/network/vertex.js"></script>
<!--<script src="../lib/network/default-vertex-renderer.js"></script>-->
<script src="../lib/network/circos-vertex-renderer.js"></script>
<script src="../lib/network/default-edge-renderer.js"></script>
<script src="../lib/network/graph-layout.js"></script>

<script src="../lib/data-adapter/network/attribute-network-data-adapter.js"></script>
<script src="../lib/data-adapter/network/json-network-data-adapter.js"></script>
<script src="../lib/data-adapter/network/sif-network-data-adapter.js"></script>
<script src="../lib/data-adapter/network/text-network-data-adapter.js"></script>
<script src="../lib/data-adapter/network/xlsx-network-data-adapter.js"></script>

<script src="../lib/data-source/data-source.js"></script>
<script src="../lib/data-source/file-data-source.js"></script>
<script src="../lib/data-source/string-data-source.js"></script>


<script src="../../bower_components/d3/d3.min.js"></script>

<!-- /build -->
<polymer-element name="jso-network-viewer"
                 attributes="">
    <template>
        <style>
            :host {
                display: block;
                position: relative;
                height: 100%;
                background-color: #FFFFFF;
            }

            jso-nv-layout {
                height: calc(100% - 96px);
            }
        </style>

        <jso-nv-tool-bar
                backgroundColor="{{backgroundColor}}"
                mode="{{mode}}"
                zoom="{{zoom}}"

                on-layoutchange="{{handleLayoutChange}}"
                on-selectchange="{{handleSelectChange}}"
                on-rotatechange="{{handleRotateChange}}"
                on-importbackgroundimage="{{handleImportBackgroundImage}}"
                ></jso-nv-tool-bar>

        <jso-nv-edition-bar
                id="editionBar"

                on-vertexshape="{{handleVertexShape}}"
                on-vertexopacity="{{handleVertexOpacity}}"
                on-vertexsize="{{handleVertexSize}}"
                on-vertexcolor="{{handleVertexColor}}"
                on-vertexstrokesize="{{handleVertexStrokeSize}}"
                on-vertexstrokecolor="{{handleVertexStrokeColor}}"
                on-vertexlabelsize="{{handleVertexLabelSize}}"
                on-vertexsearch="{{handleVertexSearch}}"
                on-vertexnamefield="{{handleVertexNameField}}"

                on-edgeshape="{{handleEdgeShape}}"
                on-edgesize="{{handleEdgeSize}}"
                on-edgecolor="{{handleEdgeColor}}"
                on-edgelabelsize="{{handleEdgeLabelSize}}"
                on-edgesearch="{{handleEdgeSearch}}"
                on-edgenamefield="{{handleEdgeNameField}}"

                ></jso-nv-edition-bar>

        <jso-nv-layout
                id="networkLayout"
                mode="{{mode}}"
                scale="{{scale}}" tx="{{tx}}" ty="{{ty}}"
                zoom="{{zoom}}"
                graph="{{graph}}"

                backgroundColor="{{backgroundColor}}"

                on-wheel="{{handleWheel}}"

                on-createvertex="{{handleCreateVertex}}"
                on-selectvertex="{{handleSelectVertex}}"
                on-moveselectedvertices="{{handleMoveSelectedVertices}}"
                on-selectarea="{{handleSelectArea}}"
                on-createedge="{{handleCreateEdge}}"
                on-removevertex="{{handleRemoveVertex}}"
                on-leftclickvertex="{{handleLeftClickVertex}}"
                on-selectedge="{{handleSelectEdge}}"
                on-leftclickedge="{{handleLeftClickEdge}}"
                on-rightclickvertex="{{handleRightClickVertex}}"
                on-rightclickbackgroundimage="{{handleRightClickBackgroundImage}}"

                ></jso-nv-layout>

        <jso-nv-status-bar></jso-nv-status-bar>
    </template>
    <script>
        Polymer({
            created: function () {
                this.serializeVersion = 2;
                this.serializeKey = 'NETWORKVIEWER' + this.serializeVersion;

                this.zoom = 25;
                this.backgroundImages = [];
                this.backgroundColor = '#FFF';
                this.center = {
                    x: 0,
                    y: 0
                };

                this.vertexDefaults = {
                    shape: 'circle',
                    size: 40,
//            color: '#9fc6e7',
                    color: '#FFFFFF',
                    strokeSize: 2,
//            strokeColor: '#9fc6e7',
                    strokeColor: '#888888',
                    opacity: 1,
                    labelSize: 12,
                    labelColor: '#111111',
                    labelPositionX: 0,
                    labelPositionY: 0,
                    labelAttribute: 'id',
                    xAttribute: 'x',
                    yAttribute: 'y'
                };
                this.edgeDefaults = {
                    shape: 'undirected',
                    shaft: 'line',
                    size: 1,
                    color: '#888888',
//            color: '#cccccc',
                    opacity: 1,
                    labelSize: 0,
                    labelColor: '#111111',
                    labelAttribute: 'id'
                };
                this.vertexVisualSets = {
                    labelSize: null,
                    opacity: null,
                    shape: null,
                    color: null,
                    strokeColor: null,
                    size: null,
                    strokeSize: null
                };
                this.edgeVisualSets = {
                    labelSize: null,
                    opacity: null,
                    shape: null,
                    shaft: null,
                    color: null,
                    size: null
                };

                this.graph = new Graph();
                this.vAttr = new AttributeManagerMemory();
                this.eAttr = new AttributeManagerMemory();

                this._createAttrColumns();

                this.mode = "select";
                this.scale;
                this.tx;
                this.ty;
            },
            _createAttrColumns: function () {
                this.vAttr.addColumn({
                    defaultValue: "",
                    name: "id",
                    title: "Id",
                    type: "string"
                });
                this.vAttr.addColumn({
                    defaultValue: "",
                    name: "name",
                    title: "Name",
                    type: "string",
                    cellTemplate: "inputTemplate"
                });

                this.eAttr.addColumn({
                    defaultValue: "",
                    name: "id",
                    title: "Id",
                    type: "string"
                });
                this.eAttr.addColumn({
                    defaultValue: "",
                    name: "name",
                    title: "Name",
                    type: "string",
                    cellTemplate: "inputTemplate"
                });
                this.eAttr.addColumn({
                    defaultValue: "",
                    name: "relation",
                    title: "Relation",
                    type: "string",
                    cellTemplate: "inputTemplate"
                });
            },
            ready: function () {
            },
            loadLocalStorage: function () {
                var item = window.localStorage.getItem(this.serializeKey);
                if (item !== null && item !== "null") {
                    this.loadJSON(JSON.parse(window.localStorage.getItem(this.serializeKey)));
                    return true;
                }
                return false;
            },
            saveLocalStorage: function () {
                window.localStorage.setItem(this.serializeKey, JSON.stringify(this));
                console.log('saved');
            },
            deleteLocalStorage: function () {
                window.localStorage.setItem(this.serializeKey, null);
                localStorage.removeItem(this.serializeKey);
            },
            loadJSON: function (o) {
                this.zoom = o.zoom;
                this.backgroundImages = o.backgroundImages;
                this.backgroundColor = o.backgroundColor;
                this.center = o.center;
                this.vertexDefaults = o.vertexDefaults;
                this.edgeDefaults = o.edgeDefaults;
                this.vertexVisualSets = o.vertexVisualSets;
                this.edgeVisualSets = o.edgeVisualSets;

                var graph = new Graph();
                graph.fromJSON(o.graph);
                this.setGraph(graph);

                this.vAttr = new AttributeManagerMemory();
                this.eAttr = new AttributeManagerMemory();
                this.vAttr.fromJSON(o.vAttr);
                this.eAttr.fromJSON(o.eAttr);
            },
            toJSON: function () {
                return {
                    zoom: this.zoom,
                    backgroundImages: this.backgroundImages,
                    backgroundColor: this.backgroundColor,
                    center: this.center,
                    vertexDefaults: this.vertexDefaults,
                    edgeDefaults: this.edgeDefaults,
                    vertexVisualSets: this.vertexVisualSets,
                    edgeVisualSets: this.edgeVisualSets,
                    graph: this.graph,
                    vAttr: this.vAttr,
                    eAttr: this.eAttr
                };
            },
            /* Observers */
            observe: {
                'vAttr.selected': 'handleVertexSelected',
                'eAttr.selected': 'handleEdgeSelected',

                'vertexDefaults.xAttribute': 'handleVertexPositionX',
                'vertexDefaults.yAttribute': 'handleVertexPositionY',
                'vertexDefaults.labelPositionX': 'handleVertexDefaultsNoUpdate',
                'vertexDefaults.labelPositionY': 'handleVertexDefaultsNoUpdate',
                'vertexDefaults.labelAttribute': 'handleVertexDefaultsNoUpdate',

                'vertexDefaults.labelSize': 'handleVertexLabelSizeProperty',
                'vertexVisualSets.labelSize': 'handleVertexLabelSizeProperty',
                'vertexVisualSets.labelSize.enabled': 'handleVertexLabelSizeProperty',

                'vertexDefaults.opacity': 'handleVertexOpacityProperty',
                'vertexVisualSets.opacity': 'handleVertexOpacityProperty',
                'vertexVisualSets.opacity.enabled': 'handleVertexOpacityProperty',

                'vertexDefaults.shape': 'handleVertexShapeProperty',
                'vertexVisualSets.shape': 'handleVertexShapeProperty',
                'vertexVisualSets.shape.enabled': 'handleVertexShapeProperty',

                'vertexDefaults.color': 'handleVertexColorProperty',
                'vertexVisualSets.color': 'handleVertexColorProperty',
                'vertexVisualSets.color.enabled': 'handleVertexColorProperty',

                'vertexDefaults.strokeColor': 'handleVertexStrokeColorProperty',
                'vertexVisualSets.strokeColor': 'handleVertexStrokeColorProperty',
                'vertexVisualSets.strokeColor.enabled': 'handleVertexStrokeColorProperty',

                'vertexDefaults.size': 'handleVertexSizeProperty',
                'vertexVisualSets.size': 'handleVertexSizeProperty',
                'vertexVisualSets.size.enabled': 'handleVertexSizeProperty',

                'vertexDefaults.strokeSize': 'handleVertexStrokeSizeProperty',
                'vertexVisualSets.strokeSize': 'handleVertexStrokeSizeProperty',
                'vertexVisualSets.strokeSize.enabled': 'handleVertexStrokeSizeProperty',


                'edgeDefaults.labelSize': 'handleEdgeLabelSizeProperty',
                'edgeVisualSets.labelSize': 'handleEdgeLabelSizeProperty',
                'edgeVisualSets.labelSize.enabled': 'handleEdgeLabelSizeProperty',

                'edgeDefaults.opacity': 'handleEdgeOpacityProperty',
                'edgeVisualSets.opacity': 'handleEdgeOpacityProperty',
                'edgeVisualSets.opacity.enabled': 'handleEdgeOpacityProperty',

                'edgeDefaults.shaft': 'handleEdgeShaftProperty',
                'edgeVisualSets.shaft': 'handleEdgeShaftProperty',
                'edgeVisualSets.shaft.enabled': 'handleEdgeShaftProperty',

                'edgeDefaults.shape': 'handleEdgeShapeProperty',
                'edgeVisualSets.shape': 'handleEdgeShapeProperty',
                'edgeVisualSets.shape.enabled': 'handleEdgeShapeProperty',

                'edgeDefaults.color': 'handleEdgeColorProperty',
                'edgeVisualSets.color': 'handleEdgeColorProperty',
                'edgeVisualSets.color.enabled': 'handleEdgeColorProperty',

                'edgeDefaults.size': 'handleEdgeSizeProperty',
                'edgeVisualSets.size': 'handleEdgeSizeProperty',
                'edgeVisualSets.size.enabled': 'handleEdgeSizeProperty'

            },
            handleVertexSelected: function (oldValue, newValue) {
                //Set all not selected
                for (var i = 0; i < this.graph.vertices.length; i++) {
                    var vertex = this.graph.vertices[i];
                    vertex.renderer.deselect();
                }
                //Set selected ones
                for (var i = 0; i < this.vAttr.selected.length; i++) {
                    var row = this.vAttr.selected[i];
                    var vertex = this.graph.getVertexById(row.id);
                    vertex.renderer.select();
                }
            },
            handleEdgeSelected: function (oldValue, newValue) {
                //Set all not selected
                for (var i = 0; i < this.graph.edges.length; i++) {
                    var edge = this.graph.edges[i];
                    edge.renderer.deselect();
                }
                //Set selected ones
                for (var i = 0; i < this.eAttr.selected.length; i++) {
                    var row = this.eAttr.selected[i];
                    var edge = this.graph.getEdgeById(row.id);
                    edge.renderer.select();
                }
            },
            handleVertexPositionX: function (oldValue, newValue) {
                this._calculateVertexAttributeNormalization(this.vertexDefaults.xAttribute, "x", "width", false);
            },
            _calculateVertexAttributeNormalization: function (coordAttr, coord, measure, invertAxis) {
                var max, min, c;
                var row, vertex;
                for (var i = 0; i < this.graph.vertices.length; i++) {
                    vertex = this.graph.vertices[i];
                    row = this.vAttr.getRow(vertex.id);
                    c = parseFloat(row[coordAttr]);
                    if (!isNaN(c)) {
                        if (!max) {
                            max = c;
                            min = c;
                        }
                        max = Math.max(c, max);
                        min = Math.min(c, min);
                    }
                }
                var range = (max === min) ? 1 : max - min;
                var measure = this.$.networkLayout.getBoundingClientRect()[measure];

                var row, vertex, c;
                for (var i = 0; i < this.graph.vertices.length; i++) {
                    vertex = this.graph.vertices[i];
                    row = this.vAttr.getRow(vertex.id);
                    c = parseFloat(row[coordAttr]);
                    c = (c - min) * measure / range;
                    if (invertAxis) {
                        c = measure - c;
                    }
                    if (!isNaN(c)) {
                        vertex.position[coord] = c;
                        vertex.renderer.move();
                        this._updateEdgeCoords(vertex);
                    }
                }
            },
            handleVertexPositionY: function (oldValue, newValue) {
                this._calculateVertexAttributeNormalization(this.vertexDefaults.yAttribute, "y", "height", true);
            },
            handleVertexDefaultsNoUpdate: function (oldValue, newValue) {
                var row, vertex;
                for (var i = 0; i < this.graph.vertices.length; i++) {
                    vertex = this.graph.vertices[i];
                    row = this.vAttr.getRow(vertex.id);

                    vertex.renderer.setConfig(this.vertexDefaults);
                    vertex.renderer.setLabelContent(row[this.vertexDefaults.labelAttribute]);
                }
            },
            handleVertexDefaults: function () {
                var row, vertex;
                for (var i = 0; i < this.graph.vertices.length; i++) {
                    vertex = this.graph.vertices[i];
                    row = this.vAttr.getRow(vertex.id);
                    vertex.renderer.setConfig(this.vertexDefaults);
                    vertex.renderer.setLabelContent(row[this.vertexDefaults.labelAttribute]);
                    vertex.renderer.update();
                    this._updateEdgeCoords(vertex);
                }
            },
            handleVertexVisualSet: function (visualSet) {
                if (visualSet) {
                    var vertex, row, rowRenderValue;
                    for (var i = 0; i < this.graph.vertices.length; i++) {
                        vertex = this.graph.vertices[i];
                        row = this.vAttr.getRow(vertex.id);
                        rowRenderValue = visualSet.matches[row[visualSet.attribute]];
                        if (rowRenderValue) {
                            vertex.renderer.set(visualSet.renderProperty, rowRenderValue);
                            this._updateEdgeCoords(vertex);
                        }
                    }
                }
            },
            handleEdgeDefaults: function () {
                var row, edge;
                for (var i = 0; i < this.graph.edges.length; i++) {
                    edge = this.graph.edges[i];
                    row = this.eAttr.getRow(edge.id);
                    edge.renderer.setConfig(this.edgeDefaults);
                    edge.renderer.update();
                }
            },
            handleEdgeVisualSet: function (visualSet) {
                if (visualSet) {
                    var edge, row, rowRenderValue;
                    for (var i = 0; i < this.graph.edges.length; i++) {
                        edge = this.graph.edges[i];
                        row = this.eAttr.getRow(edge.id);
                        rowRenderValue = visualSet.matches[row[visualSet.attribute]];
                        if (rowRenderValue) {
                            edge.renderer.set(visualSet.renderProperty, rowRenderValue);
                        }
                    }
                }
            },
            /** **/
            _handleVertexDisplayProperty: function (displayProperty) {
                if (this.vertexVisualSets[displayProperty] && this.vertexVisualSets[displayProperty].enabled) {
                    this.handleVertexVisualSet(this.vertexVisualSets[displayProperty]);
                } else {
                    this.handleVertexDefaults();
                }
                for (var dp in this.vertexVisualSets) {
                    if (dp !== displayProperty && this.vertexVisualSets[dp] && this.vertexVisualSets[dp].enabled) {
                        this.handleVertexVisualSet(this.vertexVisualSets[dp]);
                    }
                }
            },
            _handleEdgeDisplayProperty: function (displayProperty) {
                if (this.edgeVisualSets[displayProperty] && this.edgeVisualSets[displayProperty].enabled) {
                    this.handleEdgeVisualSet(this.edgeVisualSets[displayProperty]);
                } else {
                    this.handleEdgeDefaults();
                }
                for (var dp in this.edgeVisualSets) {
                    if (dp !== displayProperty && this.edgeVisualSets[dp] && this.edgeVisualSets[dp].enabled) {
                        this.handleEdgeVisualSet(this.edgeVisualSets[dp]);
                    }
                }
            },
            handleVertexLabelSizeProperty: function (oldValue, newValue) {
                this._handleVertexDisplayProperty("labelSize");
            },
            handleVertexOpacityProperty: function (oldValue, newValue) {
                this._handleVertexDisplayProperty("opacity");
            },
            handleVertexShapeProperty: function (oldValue, newValue) {
                this._handleVertexDisplayProperty("shape");
            },
            handleVertexColorProperty: function (oldValue, newValue) {
                this._handleVertexDisplayProperty("color");
            },
            handleVertexStrokeColorProperty: function (oldValue, newValue) {
                this._handleVertexDisplayProperty("strokeColor");
            },
            handleVertexSizeProperty: function (oldValue, newValue) {
                this._handleVertexDisplayProperty("size");
            },
            handleVertexStrokeSizeProperty: function (oldValue, newValue) {
                this._handleVertexDisplayProperty("strokeSize");
            },

            handleEdgeLabelSizeProperty: function (oldValue, newValue) {
                this._handleEdgeDisplayProperty("labelSize");
            },
            handleEdgeOpacityProperty: function (oldValue, newValue) {
                this._handleEdgeDisplayProperty("opacity");
            },
            handleEdgeShaftProperty: function (oldValue, newValue) {
                this._handleEdgeDisplayProperty("shaft");
            },
            handleEdgeShapeProperty: function (oldValue, newValue) {
                this._handleEdgeDisplayProperty("shape");
            },
            handleEdgeColorProperty: function (oldValue, newValue) {
                this._handleEdgeDisplayProperty("color");
            },
            handleEdgeSizeProperty: function (oldValue, newValue) {
                this._handleEdgeDisplayProperty("size");
            },
            /** **/

            /*End Observers*/


            handleWheel: function (e) {
                if (e.deltaY < 0) {
                    this.zoom = Math.min(100, this.zoom + 2);
                } else {
                    this.zoom = Math.max(0, this.zoom - 2);
                }
            },

            /* toolbar Handlers*/
            handleImportBackgroundImage: function (e) {
                this.$.networkLayout.addBackgroundImage(e.detail.image);
            },
            handleLayoutChange: function (e) {
                this.setLayout(e.detail.layout);
            },
            handleSelectChange: function (e) {
                this.select(e.detail.select);
            },
            handleRotateChange: function (e) {
                this.rotateNetwork(e.detail.angle);
            },

            /* editionbar Handlers*/
            handleVertexShape: function (e) {
                this.setSelectedVerticesDisplayAttr('shape', e.detail.value, true);
            },
            handleVertexOpacity: function (e) {
                this.setSelectedVerticesDisplayAttr('opacity', e.detail.value);
            },
            handleVertexSize: function (e) {
                this.setSelectedVerticesDisplayAttr('size', parseInt(e.detail.value), true);
            },
            handleVertexColor: function (e) {
                this.setSelectedVerticesDisplayAttr('color', e.detail.value);
            },
            handleVertexStrokeSize: function (e) {
                this.setSelectedVerticesDisplayAttr('strokeSize', parseInt(e.detail.value), true);
            },
            handleVertexStrokeColor: function (e) {
                this.setSelectedVerticesDisplayAttr('strokeColor', e.detail.value);
            },
            handleVertexLabelSize: function (e) {
                this.setSelectedVerticesDisplayAttr('labelSize', e.detail.value);
            },
            handleVertexSearch: function (e) {
                this.selectVerticesByAttribute('name', e.detail.value);
            },
            handleVertexNameField: function (e) {
                this.setVertexLabel(e.detail.value);
            },


            handleEdgeShape: function (e) {
                this.setSelectedEdgesDisplayAttr('shape', e.detail.value);
            },
            handleEdgeSize: function (e) {
                this.setSelectedEdgesDisplayAttr('size', parseInt(e.detail.value));
            },
            handleEdgeColor: function (e) {
                this.setSelectedEdgesDisplayAttr('color', e.detail.value);
            },
            handleEdgeLabelSize: function (e) {
                this.setSelectedEdgesDisplayAttr('labelSize', e.detail.value);
            },
            handleEdgeSearch: function (e) {
                this.selectEdgesByAttribute('name', e.detail.value);
            },
            handleEdgeNameField: function (e) {
                this.setEdgeLabel(e.detail.value);
            },

            /*Layout Handlers*/
            handleCreateVertex: function (e) {
                this.createVertex(e.detail.x, e.detail.y);
            },
            handleSelectVertex: function (e) {
                var vertex = this.graph.getVertexById(e.detail.vertexId);
                this.selectVertex(vertex, e.detail.addToSelection);
            },
            handleSelectEdge: function (e) {
                var edge = this.graph.getEdgeById(e.detail.edgeId);
                this.selectEdge(edge, e.detail.addToSelection);
            },

            handleMoveSelectedVertices: function (e) {
                this.moveSelectedVertices(e.detail.dispX, e.detail.dispY);
            },
            handleSelectArea: function (e) {
                this.selectByArea(e.detail.x, e.detail.y, e.detail.width, e.detail.height);
            },
            handleCreateEdge: function (e) {
                var source = this.graph.getVertexById(e.detail.sourceId);
                var target = this.graph.getVertexById(e.detail.targetId);
                this.createEdge(source, target);

            },
            handleRemoveVertex: function (e) {
                var vertex = this.graph.getVertexById(e.detail.vertexId);
                this.removeVertex(vertex);
            },
            handleLeftClickVertex: function (e) {
                var vertex = this.graph.getVertexById(e.detail.vertexId);
                this.$.editionBar.vertexColor = vertex.renderer.color;
                this.$.editionBar.vertexStrokeColor = vertex.renderer.strokeColor;
                this.$.editionBar.vertexNameField = vertex.renderer.labelText;
                this.$.editionBar.vertexSizeField = vertex.renderer.size;
                this.$.editionBar.vertexStrokeSizeField = vertex.renderer.strokeSize;
                this.$.editionBar.selectedBar = 'vertex';
            },
            handleLeftClickEdge: function (e) {
                var edge = this.graph.getEdgeById(e.detail.edgeId);
//                var isSelected = this.edge.renderer.selected;
//                if (!isSelected) {
//                    this.selectEdge(edge);
//                }
                this.$.editionBar.edgeColor = edge.renderer.color;
                this.$.editionBar.edgeSizeField = edge.renderer.size;
                this.$.editionBar.edgeNameField = edge.renderer.labelText;
                this.$.editionBar.selectedBar = 'edge';
            },
            handleRightClickVertex: function (e) {
                //TODO
//        _this._fillVertexContextMenu(e);
//        _this.contextMenu.style.visibility = 'visible';
//        _this.contextMenu.style.opacity = '1';
//        _this.contextMenu.style.left = e.x + 'px';
//        _this.contextMenu.style.top = e.y + 'px';
            },
            handleRightClickBackgroundImage: function (e) {
                //TODO
//        _this._fillBackImageContextMenu(e);
//        _this.contextMenu.style.visibility = 'visible';
//        _this.contextMenu.style.opacity = '1';
//        _this.contextMenu.style.left = e.x + 'px';
//        _this.contextMenu.style.top = e.y + 'px';
            },


            /* Methods */
            selectAll: function () {
                this.vAttr.selectAll();
                this.eAttr.selectAll();
            },
            selectVertex: function (vertex, addToSelection) {
                if (!vertex.renderer.selected) {
                    if (addToSelection) {
                        this.vAttr.addToSelection(vertex.id);
                    } else {
                        this.vAttr.select(vertex.id);
                    }
                }
            },
            selectAllVertices: function () {
//                this.deselectAllEdges();
                this.vAttr.selectAll();
            },
            deselectAllVertices: function () {
                this.vAttr.deselectAll();
            },
            selectEdge: function (edge, addToSelection) {
                if (!edge.renderer.selected) {
                    if (addToSelection) {
                        this.eAttr.addToSelection(edge.id);
                    } else {
                        this.eAttr.select(edge.id);
                    }
                }
            },
            selectAllEdges: function () {
//                this.deselectAllVertices();
                this.eAttr.selectAll();
            },
            deselectAllEdges: function () {
                this.eAttr.deselectAll();
            },

            selectVerticesNeighbour: function () {
                var selectedVertices = [];
                var selectedVerticesMap = {};
                for (var i = 0; i < this.vAttr.selected.length; i++) {
                    var row = this.vAttr.selected[i];
                    var vertex = this.graph.getVertexById(row.id);
                    selectedVertices.push(vertex);
                    selectedVerticesMap[vertex.id] = vertex;
                    for (var j = 0; j < vertex.edges.length; j++) {
                        var edge = vertex.edges[j];
                        if (!selectedVerticesMap[edge.source.id]) {
                            selectedVertices.push(edge.source);
                            selectedVerticesMap[edge.source.id] = edge.source;
                        }
                        if (!selectedVerticesMap[edge.target.id]) {
                            selectedVertices.push(edge.target);
                            selectedVerticesMap[edge.target.id] = edge.target;
                        }
                    }
                }
                this.vAttr.selected = selectedVertices;
            },
            selectEdgesNeighbour: function () {
                for (var i = 0; i < this.vAttr.selected.length; i++) {
                    var row = this.vAttr.selected[i];
                    var vertex = this.graph.getVertexById(row.id);
                    for (var j = 0; j < vertex.edges.length; j++) {
                        var edge = vertex.edges[j];
                        if (!edge.renderer.selected) {
                            this.eAttr.addToSelection(edge.id);
                        }
                    }
                }
            },
            selectVerticesInvert: function () {
                var selected = [];
                for (var i = 0; i < this.graph.vertices.length; i++) {
                    var vertex = this.graph.vertices[i];
                    if (!vertex.renderer.selected) {
                        selected.push(this.vAttr.getRow(vertex.id));
                    }
                }
                this.vAttr.selected = selected;
            },
            selectByArea: function (x, y, width, height) {
                this.deselectAllVertices();
                this.deselectAllEdges();
                if (width > 0 && height > 0) {
                    x -= this.tx;
                    y -= this.ty;
                    x /= this.scale;
                    y /= this.scale;

                    width /= this.scale;
                    height /= this.scale;

                    var vSelected = [];
                    var eSelected = [];
                    for (var i = 0; i < this.graph.vertices.length; i++) {
                        var vertex = this.graph.vertices[i];
                        if (vertex.position.x >= x && vertex.position.x <= x + width && vertex.position.y >= y && vertex.position.y <= y + height) {
                            vSelected.push(this.vAttr.getRow(vertex.id));

                            for (var j = 0; j < vertex.edges.length; j++) {
                                var edge = vertex.edges[j];
                                eSelected.push(this.eAttr.getRow(edge.id));
                            }

                        }
                    }
                    this.vAttr.selected = vSelected;
                    this.eAttr.selected = eSelected;
                }
            },
            _updateEdgeCoords: function (vertex) {
                for (var i = 0; i < vertex.edges.length; i++) {
                    var edge = vertex.edges[i];
                    if (vertex === edge.source) {
                        edge.renderer.move();
                    }
                    if (vertex === edge.target) {
                        edge.renderer.move();
                    }
                }
            },
            moveSelectedVertices: function (dispX, dispY) {
                dispX /= this.scale;
                dispY /= this.scale;
                for (var i = 0; i < this.vAttr.selected.length; i++) {
                    var row = this.vAttr.selected[i];
                    var vertex = this.graph.getVertexById(row.id);
                    vertex.position.x += dispX;
                    vertex.position.y += dispY;
                    vertex.renderer.move();
                    this._updateEdgeCoords(vertex);
                }
            },

            selectVerticesByIds: function (vertexIds) {
                this.deselectAllVertices();
                this.vAttr.selectByIds(vertexIds);
            },
            selectVerticesByAttribute: function (attributeName, attributeValue) {
                this.deselectAllVertices();
                this.vAttr.selectByColumnValue(attributeName, attributeValue);
            },
            selectEdgesByAttribute: function (attributeName, attributeValue) {
                this._deselectAllEdges();
                this.eAttr.selectByColumnValue(attributeName, attributeValue);
            },
            setVertexCoords: function (vertexId, x, y) {
                var vertex = this.graph.getVertexById(vertexId);
                vertex.position.x = x;
                vertex.position.y = y;
                vertex.renderer.move();
                this._updateEdgeCoords(vertex);
            },
            removeVertex: function (vertex) {
                for (var i = 0; i < vertex.edges.length; i++) {
                    var edge = vertex.edges[i];
                    edge.renderer.remove();
                    this.eAttr.removeRowById(edge.id);
                }
                vertex.renderer.remove();
                this.vAttr.removeRowById(vertex.id);
                this.graph.removeVertex(vertex);
                this.deselectAllVertices();
            },
            removeSelectedVertices: function () {
                var edgeRowsToDelete = [];
                var edgeRowsToDeleteMap = {};
                var selectedVertices = [];
                for (var i = 0; i < this.vAttr.selected.length; i++) {
                    var row = this.vAttr.selected[i];
                    var vertex = this.graph.getVertexById(row.id);
                    selectedVertices.push(vertex);
                    for (var j = 0; j < vertex.edges.length; j++) {
                        var edge = vertex.edges[j];
                        edge.renderer.remove();
                        if (edgeRowsToDeleteMap[edge.id] != true) {
                            edgeRowsToDeleteMap[edge.id] = true;
                            edgeRowsToDelete.push(this.eAttr.getRow(edge.id));
                        }
                    }
                    vertex.renderer.remove();
                }
                this.graph.removeVertices(selectedVertices);
                this.vAttr.removeSelected();
                this.eAttr.removeRows(edgeRowsToDelete);
            },
            setSelectedVerticesDisplayAttr: function (displayProperty, value, updateEdges) {
                var vertex, row;
                for (var i = 0, li = this.vAttr.selected.length; i < li; i++) {
                    row = this.vAttr.selected[i];
                    vertex = this.graph.getVertexById(row.id);
                    vertex.renderer.set(displayProperty, value);
                    if (updateEdges) {
                        this._updateEdgeCoords(vertex);
                    }
                }
            },
            setSelectedEdgesDisplayAttr: function (displayProperty, value) {
                var edge, row;
                for (var i = 0, li = this.eAttr.selected.length; i < li; i++) {
                    row = this.eAttr.selected[i];
                    edge = this.graph.getEdgeById(row.id);
                    edge.renderer.set(displayProperty, value);
                }
            },
            setVertexLabel: function (label) {
                //TODO
//                if (this.selectedVertices.length == 1) {
//                    var vertex = this.selectedVertices[0];
//                    this.network.setVertexLabel(vertex, label);
//                }
            },
            setEdgeLabel: function (label) {
                //TODO
//                if (this.selectedEdges.length == 1) {
//                    var edge = this.selectedEdges[0];
//                    this.network.setEdgeLabel(edge, label);
//                }
            },
            createVertex: function (x, y) {
                x -= this.tx;
                y -= this.ty;
                x /= this.scale;
                y /= this.scale;

                var id = Math.floor(Math.random() * (999999 - 100000 + 1)) + 100000;

                /* vertex graph */
                var vertex = new Vertex({
                    id: 'n' + id,
                    position: new Point(x, y),
                    renderer: new CircosVertexRenderer(this.vertexDefaults)
                });
                var added = this.graph.addVertex(vertex);
                if (added) {
                    this.vAttr.addRow({
                        'id': vertex.id,
                        'name': vertex.id
                    });
                    vertex.render({
                        target: this.$.networkLayout.$.scaleFrontGroup
                    });
                }
                return vertex;
            },
            createEdge: function (vertexSource, vertexTarget) {
                var relation = 'i';
                /* edge graph */
                var edge = new Edge({
                    id: vertexSource.id + '_' + relation + '_' + vertexTarget.id,
                    relation: relation,
                    source: vertexSource,
                    target: vertexTarget,
                    renderer: new DefaultEdgeRenderer(this.edgeDefaults)
                });

//                this.session.getEdgeDefaults()

                var added = this.graph.addEdge(edge);
                if (added) {
                    this.eAttr.addRow({
                        'id': edge.id,
                        'name': edge.id,
                        'relation': edge.relation
                    });
                    edge.render({
                        target: this.$.networkLayout.$.scaleFrontGroup
                    });
                }
                return edge;
            },
            removeBackGroundImage: function (imageEl) {
                if (imageEl && imageEl.parentNode) {
                    imageEl.parentNode.removeChild(imageEl);
                }
            },
            rotateNetwork: function (angle) {
                var intPattern = /^-?\d+$/;
                if (angle && intPattern.test(angle)) {
                    var clientRect = this.$.networkLayout.getBoundingClientRect();
                    var centerX = clientRect.width / 2;
                    var centerY = clientRect.height / 2;
                    var vertices = this.graph.vertices;

                    var rotationInRadians = angle * Math.PI / 180.0;

                    for (var i = 0, l = vertices.length; i < l; i++) {
                        var vertex = vertices[i];
                        var vCoords = vertex.position;

                        //Detect angle and radius using width/2 and height/2 as center
                        var deltaX = vCoords.x - centerX;
                        var deltaY = vCoords.y - centerY;
                        var radius = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
                        var delta = deltaY / deltaX;
                        var angleRad = (isNaN(delta)) ? 0 : Math.atan(delta) + rotationInRadians;
                        //Fix Quadrant
                        angleRad = (vCoords.x < centerX) ? angleRad += Math.PI : angleRad;

                        var x = centerX + (radius * Math.cos(angleRad));
                        var y = centerY + (radius * Math.sin(angleRad));
                        //
                        this.setVertexCoords(vertex.id, x, y);
                    }
                }
            },
            setLayout: function (type, e) {
                var me = this;
                this.x = 0;
                this.y = 0;
                var graph = this.graph;
                var dot = graph.getAsDOT();
                var clientRect = this.$.networkLayout.getBoundingClientRect();
                var width = clientRect.width;
                var height = clientRect.height;
                switch (type) {
                    case "Circle":
                        if (e && typeof e.attributeName !== 'undefined') {
                            GraphLayout.circle(me, width, height, this.network.getVerticesOrdered(e.attributeName));
                        } else {
                            GraphLayout.circle(me, width, height);
                        }
                        break;
                    case "Random":
                        GraphLayout.random2d(me, width, height);
                        break;
                    case "none":
                        break;
                    case "Force directed":
                        GraphLayout.force({
                            network: me,
                            width: width,
                            height: height,
                            end: function (verticesArray) {
                                for (var i = 0, l = verticesArray.length; i < l; i++) {
                                    var v = verticesArray[i];
                                    var vertex = me.graph.getVertexById(v.id);
                                    vertex.position.x = v.x;
                                    vertex.position.y = v.y;
                                    vertex.renderer.move();
                                    me._updateEdgeCoords(vertex);
                                }
                            }
                        });
                        break;
                    case "Force directed (simulation)":
                        GraphLayout.force({
                            network: me,
                            width: width,
                            height: height,
                            simulation: true,
                            end: function (verticesArray) {
                                for (var i = 0, l = verticesArray.length; i < l; i++) {
                                    var v = verticesArray[i];
                                    var vertex = me.graph.getVertexById(v.id);
                                    vertex.position.x = v.x;
                                    vertex.position.y = v.y;
                                    vertex.renderer.move();
                                    me._updateEdgeCoords(vertex);
                                }
                            }
                        });
                        break;
                    default:
                        console.log(dot);
//                var url = "http://bioinfo.cipf.es/utils/ws/rest/network/layout/" + type.toLowerCase() + ".coords";
////        		var url = "http://localhost:8080/opencga/rest/utils/network/layout/"+type+".coords";
////                var url = "http://ws-beta.bioinfo.cipf.es/opencga-staging/rest/utils/network/layout/" + type.toLowerCase() + ".coords";
//                $.ajax({
//                    async: false,
//                    type: "POST",
//                    url: url,
//                    dataType: "json",
//                    data: {
//                        dot: dot
//                    },
//                    cache: false,
//                    success: function (data) {
//                        console.log('Layout back')
//                        for (var vertexId in data) {
//                            var x = _this.getLayoutWidth() * (0.05 + 0.85 * data[vertexId].x);
//                            var y = _this.getLayoutHeight() * (0.05 + 0.85 * data[vertexId].y);
//                            _this.setVertexCoords(vertexId, x, y);
//                        }
//                    },
//                    error: function (data) {
//                        debugger
//                    },
//
//                });
                        break;
                }
            },
            select: function (option) {
                switch (option) {
                    case 'All nodes' :
                        this.selectAllVertices();
                        break;
                    case 'All edges' :
                        this.selectAllEdges();
                        break;
                    case 'Everything' :
                        this.selectAll();
                        break;
                    case 'First neighbour nodes' :
                        this.selectVerticesNeighbour();
                        break;
                    case 'Invert node selection' :
                        this.selectVerticesInvert();
                        break;
                    case 'Adjacent edges' :
                        this.selectEdgesNeighbour();
                        break;
                    default :
                        console.log(option + " not defined");
                }
            },
            getAsSIF: function (separator) {
                return this.network.getAsSIF(separator);
            },

            setGraph: function (graph) {
                this.graph = graph;
                this.vAttr = new AttributeManagerMemory();
                this.eAttr = new AttributeManagerMemory();
                this._createAttrColumns();
                this.$.networkLayout.clean();

                this.$.networkLayout.removeDom();
                var edges = this.graph.edges;
                var vertices = this.graph.vertices;
                for (var i = 0, l = vertices.length; i < l; i++) {
                    var vertex = vertices[i];
                    this.vAttr.addRow({
                        'id': vertex.id,
                        'name': vertex.id
                    });
                    vertex.setRenderer(new CircosVertexRenderer(this.vertexDefaults));
                    vertex.render({
                        target: this.$.networkLayout.$.scaleFrontGroup
                    });
                }
                for (var i = 0, l = edges.length; i < l; i++) {
                    var edge = edges[i];
                    this.eAttr.addRow({
                        'id': edge.id,
                        'name': edge.id,
                        'relation': edge.relation
                    });
                    edge.setRenderer(new DefaultEdgeRenderer(this.edgeDefaults));
                    edge.render({
                        target: this.$.networkLayout.$.scaleFrontGroup
                    });
                }
                this.$.networkLayout.appendDom();
            },

            importVertexAttributeManager: function (attributeManager) {
                var columns = attributeManager.columns;
                var data = attributeManager.data;
                for (var i = 0; i < columns.length; i++) {
                    var column = columns[i];
                    this.vAttr.addColumn(column);
                }
                for (var i = 0; i < data.length; i++) {
                    var row = data[i];
                    if (this.graph.containsVertex({id: row.id})) {
                        var added = this.vAttr.addRow(row);
                        if (added == false) {
                            var currentRow = this.vAttr.getRow(row.id);
                            for (key in row) {
                                currentRow[key] = row[key];
                            }
                        }
                    }
                }
                this.handleVertexPositionX();
                this.handleVertexPositionY();
            },
            importEdgeAttributeManager: function (attributeManager) {
                var columns = attributeManager.columns;
                var data = attributeManager.data;
                for (var i = 0; i < columns.length; i++) {
                    var column = columns[i];
                    this.eAttr.addColumn(column);
                }
                for (var i = 0; i < data.length; i++) {
                    var row = data[i];
                    if (this.graph.containsEdge({id: row.id})) {
                        var added = this.eAttr.addRow(row);
                        if (added == false) {
                            var currentRow = this.eAttr.getRow(row.id);
                            for (key in row) {
                                currentRow[key] = row[key];
                            }
                        }
                    }
                }
            },
            __iliketomoveit: function () {
                this.setLayout('Force directed (simulation)')
            }
        });
    </script>
</polymer-element>